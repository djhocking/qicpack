?lib
?library
libPaths()
.libPaths()
rm(Read-and-delete-me)
rm('Read-and-delete-me')
?devtools::create
install.packages('devtools')
library(devtools)
devtools::create
?create
package.skeleton(name = "QICtest", list = "QIC")
INSTALL(QICtest)
install.packages('QICtest')
QICtest
ls()
install.packages("~/QICtest/man/QICtest-package.Rd", repos = NULL)
install.packages('Rtools')
roxygenize()
install.packages("roxygen2")
library(roxygen2)
roxengize()
?roxygen2
roxygenize(QICtest)
roxygenize('QICtest')
?geepack
library(geepack)
?geepack
?geeglm
?depends
?Depends
QIC
data(dietox)
dietox$Cu <- as.factor(dietox$Cu)
mf <- formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
gee1 <- geeglm(mf, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
gee1
summary(gee1)
mf2 <- formula(Weight ~ Cu * Time + I(Time^2) + I(Time^3))
gee2 <- geeglm(mf2, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
summary(gee2)
gee2 <- geeglm(mf2, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee1 <- geeglm(mf, data = dietox, id = Pig, family = poisson, corstr = "ar1")
install.packages("~/QICtest_1.0.tar.gz", repos = NULL)
?QICtest
?QIC
library(QICtest)
install.packages("~/QICtest_1.0.tgz", repos = NULL)
install.packages("~/QICtest_1.0.tgz", repos = NULL)
library(QICtest_1.0)
install.packages("car")
QIC
QIC(gee1, gee1.I)
QIC <- function(model.R, model.indep) {
library(MASS)
# Fitted and observed values for quasi likelihood
mu.R <- model.R$fitted.values
# alt: X <- model.matrix(model.R)
#  names(model.R$coefficients) <- NULL
#  beta.R <- model.R$coefficients
#  mu.R <- exp(X %*% beta.R)
y <- model.R$y
ifelse(model.R$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(model.R$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(model.R$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2)
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R))
# Quasilikelihood for Negative Binomial
quasi.R <- sum(y*log(mu.R/(k + mu.R)) + k*log(k/(k + mu.R)))
# Quasilikelihood for Gamma distribution
quasi.R <- sum(-y/(mu.R - log(mu.R)))
# Trace Term (penalty for model complexity)
AIinverse <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
# Alt: AIinverse <- solve(model.indep$geese$vbeta.naiv) # solve via indenity
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(AIinverse %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- (-2)*quasi.R + 2*trace.R
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- c(QIC, QICu, quasi.R, trace.R, px)
names(output) <- c('QIC', 'QICu', 'Quasi Lik', 'Trace', 'px')
return(output)
}
QIC <- function(model.R, model.indep) {
library(MASS)
# Fitted and observed values for quasi likelihood
mu.R <- model.R$fitted.values
# alt: X <- model.matrix(model.R)
#  names(model.R$coefficients) <- NULL
#  beta.R <- model.R$coefficients
#  mu.R <- exp(X %*% beta.R)
y <- model.R$y
ifelse(model.R$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(model.R$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(model.R$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2)
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R))
# Quasilikelihood for Negative Binomial
#quasi.R <- sum(y*log(mu.R/(k + mu.R)) + k*log(k/(k + mu.R)))
# Quasilikelihood for Gamma distribution
quasi.R <- sum(-y/(mu.R - log(mu.R)))
# Trace Term (penalty for model complexity)
AIinverse <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
# Alt: AIinverse <- solve(model.indep$geese$vbeta.naiv) # solve via indenity
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(AIinverse %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- (-2)*quasi.R + 2*trace.R
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- c(QIC, QICu, quasi.R, trace.R, px)
names(output) <- c('QIC', 'QICu', 'Quasi Lik', 'Trace', 'px')
return(output)
}
QIC(gee1, gee1.I)
gee1 <- geeglm(mf, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
gee1.I <- update(gee1, corstr = "independence")
QIC(gee1, gee1.I)
summary(dietox)
mu.R <- gee1$fitted.values
summary(mu.R)
gee1$modelInfo$variance
y <- gee1$y
summary(y)
ifelse(gee1$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(gee1$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(gee1$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
QIC <- function(model.R, model.indep) {
library(MASS)
# Fitted and observed values for quasi likelihood
mu.R <- model.R$fitted.values
# alt: X <- model.matrix(model.R)
#  names(model.R$coefficients) <- NULL
#  beta.R <- model.R$coefficients
#  mu.R <- exp(X %*% beta.R)
y <- model.R$y
ifelse(model.R$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(model.R$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(model.R$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
# Quasilikelihood for Negative Binomial
#quasi.R <- sum(y*log(mu.R/(k + mu.R)) + k*log(k/(k + mu.R)))
# Quasilikelihood for Gamma distribution
#quasi.R <- sum(-y/(mu.R - log(mu.R)))
# Trace Term (penalty for model complexity)
AIinverse <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
# Alt: AIinverse <- solve(model.indep$geese$vbeta.naiv) # solve via indenity
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(AIinverse %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- (-2)*quasi.R + 2*trace.R
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- c(QIC, QICu, quasi.R, trace.R, px)
names(output) <- c('QIC', 'QICu', 'Quasi Lik', 'Trace', 'px')
return(output)
}
QIC(gee1, gee1.I)
install.packages("~/QICtest_1.0.tar.gz", repos = NULL)
install.packages("~/QICtest_1.0.tgz", repos = NULL)
library(QICtest_1.0)
AIinverse <- MASS::ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
?library
library(car, boot)
library(c(car, boot))
.onLoad(require(MASS))
?onLoad
??onLoad
onLoad(require(MASS))
fix(gee3.I)
install.packages("~/QICtest_1.0.tgz", repos = NULL)
library(QICtest)
install.packages('QICtest_1.0.tar.gz', repos = NULL, type = "source")
library("QICtest")
QIC(gee1, gee1.I)
?sapply
sapply(list(gee1, gee2, gee3), function(x) QIC(x, gee1.I))
QIC.pois(gee1, gee1.I)
QIC.pois(gee2, gee2.I)
QIC.pois(gee3, gee3.I)
dietox$rand <- rnorm(861, 10, 5)
dietox$rand
mf4 <- formula(Weight ~ Cu + Time + I(Time^2) + rand)
gee4 <- geeglm(mf4, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee4.I <- update(gee4, corstr = "independence")
QIC(gee3, gee3.I)
QIC(gee4, gee4.I)
sm <- read.table( 'http://www.unc.edu/courses/2010spring/ecol/562/001/data/lab7/sm003.txt', header=T, sep=',')
sm[1:16,]
sm$wave <- as.numeric(factor(paste(sm$year, sm$period, sep='.')))
sm[25:46,]
geeglmfit.ind <- geeglm(nesting2~factor(year)+ factor(period)+ factor(deply)+ rblval+ factor(year)*factor(period)+ rblval*factor(period)+ size+ I(size^2), id=strtno, family=binomial(), corstr="independence", data=sm, scale.fix=T, waves=wave)
#exchangeable
geeglmfit.ex <- geeglm(nesting2~factor(year)+ factor(period)+ factor(deply)+ rblval+ factor(year)*factor(period)+ rblval*factor(period)+ size+ I(size^2), id=strtno, family=binomial(), corstr="exchangeable", data=sm, scale.fix=T, waves=wave)
#AR(1)
geeglmfit.ar1 <- geeglm(nesting2~factor(year)+ factor(period)+ factor(deply)+ rblval+ factor(year)*factor(period)+ rblval*factor(period)+ size+ I(size^2), id=strtno, family=binomial(), corstr="ar1", data=sm, scale.fix=T, waves=wave)
sapply(list(geeglmfit.ind, geeglmfit.ex, geeglmfit.ar1), function(x) QIC(x,geeglmfit.ind))
detach("package:QICtest")
QIC <- function(model.R, model.indep) {
library(MASS)
# Fitted and observed values for quasi likelihood
mu.R <- model.R$fitted.values
# alt: X <- model.matrix(model.R)
#  names(model.R$coefficients) <- NULL
#  beta.R <- model.R$coefficients
#  mu.R <- exp(X %*% beta.R)
y <- model.R$y
ifelse(model.R$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(model.R$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(model.R$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
# Quasilikelihood for Negative Binomial
#quasi.R <- sum(y*log(mu.R/(k + mu.R)) + k*log(k/(k + mu.R)))
# Quasilikelihood for Gamma distribution
#quasi.R <- sum(-y/(mu.R - log(mu.R)))
# Trace Term (penalty for model complexity)
#AIinverse <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
AIinverse <- solve(model.indep$geese$vbeta.naiv) # solve via indenity
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(AIinverse %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- (-2)*quasi.R + 2*trace.R
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- c(QIC, QICu, quasi.R, trace.R, px)
names(output) <- c('QIC', 'QICu', 'Quasi Lik', 'Trace', 'px')
return(output)
}
sapply(list(geeglmfit.ind, geeglmfit.ex, geeglmfit.ar1), function(x) QIC(x,geeglmfit.ind))
QIC(gee3, gee3.I)
QIC(gee4, gee4.I)
mf5 <- formula(Weight ~ Cu + Time + I(Time^2) + rand + I(rand^2) + I(rand^3))
gee5 <- geeglm(mf5, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee5.I <- update(gee5, corstr = "independence")
QIC(gee5, gee5.I)
mf5 <- formula(Weight ~ Cu + Time + I(Time^2) + rand + I(rand^2) + I(rand^3) + I(rand^4))
gee5 <- geeglm(mf5, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee5.I <- update(gee5, corstr = "independence")
QIC(gee4, gee4.I)
QIC(gee5, gee5.I)
QIC <- function(model.R) {
library(MASS)
model.indep <- update(model.R, corstr = "independence")
# Fitted and observed values for quasi likelihood
mu.R <- model.R$fitted.values
# alt: X <- model.matrix(model.R)
#  names(model.R$coefficients) <- NULL
#  beta.R <- model.R$coefficients
#  mu.R <- exp(X %*% beta.R)
y <- model.R$y
ifelse(model.R$modelInfo$variance == "poisson",
# Quasi Likelihood for Poisson
quasi.R <- sum((y*log(mu.R)) - mu.R),
ifelse(model.R$modelInfo$variance == "gaussian",
# Quasi Likelihood for Normal
quasi.R <- sum(((y - mu.R)^2)/-2),
ifelse(model.R$modelInfo$variance == "binomial",
# Quasilikelihood for Binomial
quasi.R <- sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
quasi.R <- "Error: distribution not recognized")))
# Quasilikelihood for Negative Binomial
#quasi.R <- sum(y*log(mu.R/(k + mu.R)) + k*log(k/(k + mu.R)))
# Quasilikelihood for Gamma distribution
#quasi.R <- sum(-y/(mu.R - log(mu.R)))
# Trace Term (penalty for model complexity)
#AIinverse <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
AIinverse <- solve(model.indep$geese$vbeta.naiv) # solve via indenity
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(AIinverse %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- (-2)*quasi.R + 2*trace.R
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- c(QIC, QICu, quasi.R, trace.R, px)
names(output) <- c('QIC', 'QICu', 'Quasi Lik', 'Trace', 'px')
return(output)
}
QIC(gee5)
sapply(list(gee1, gee2, gee3), function(x) QIC(x))
sapply(list(gee1, gee2, gee3, gee4, gee5), function(x) QIC(x))
?sapply
sapply(list(gee1, gee2, gee3, gee4, gee5), QIC)
?response
model.R <- gee3
model.indep <- update(model.R, corstr = "independence")
mu.R <- model.R$fitted.values
y <- model.R$y
type <- family(model.R)$family
quasi.R <- function(type, y){
switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
stop("Error: distribution not recognized"))
}
quasi.R
?switch
switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
stop("Error: distribution not recognized"))
?family
type
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose generalized inverse of a matrix in MASS package
omegaI
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
trace.R
length(y)
length(mu.R)
?unmarked
library(unmarked)
?unmarked
?geepack
?geeglm
?geese
memory.limit()
??memory
memory.profile()
Hares$density
hares <- read.table('/Users/Dan/Documents/Statistics/Kery-WinBUGS/hares.data.txt', header = TRUE)
attach(hares)
aggregate(mean.density, by = list(region, landuse), FUN = mean, na.rm = TRUE)
table(region, landuse)
# Write model
sink("model.txt")
cat("
model {
# Priors
for (i in 1:2){
for(j in 1:8) {
group.mean[i,j] ~ dnorm(0, 0.0001)
}
}
sigma ~ dunif(0, 100)
# Likelihood
for (i in 1:n) {
mean.density[i] ~ dnorm(mean[i], tau)
mean[i] <- group.mean[landuse[i], region[i]]
}
# Derived quantities
tau <- 1 / ( sigma * sigma)
for(j in 1:8){
diff.density[j] <- group.mean[1,j] - group.mean[2,j]
}
}
",fill=TRUE)
sink()
# Bundle data
win.data <- list(mean.density=mean.density, region = as.numeric(region), landuse = as.numeric(landuse),
n = length(mean.density))
# Inits function
inits <- function(){list(sigma = rlnorm(1) )}
# Parameters to estimate
params <- c("group.mean", "sigma", "diff.density")
# MCMC settings
ni <- 6000
nb <- 2000
nt <- 2
nc <- 3
# Start Gibbs sampling
out <- jags(win.data, inits, params, "model.txt", n.thin=nt, n.chains=nc, n.burnin=nb, n.iter=ni)
library(R2jags)
out <- jags(win.data, inits, params, "model.txt", n.thin=nt, n.chains=nc, n.burnin=nb, n.iter=ni)
print(out, dig = 3)
n.landuse
head(hares)
set.seed(12345)
x <- rnorm(10, 2)
x <- rnorm(100, 10, 2)
set.seed(12345)
x <- rnorm(100, 10, 2)
x
?model.matrix
model.matrix(~ x + x2)
ap = 5
bp = 2
bp2 = 3
set.seed(12345)
x <- rnorm(10, 10, 2)
x2 <- rnorm(10, 3, 1)
xs <- (x - mean(x)/sd(x))
x2s <- (x2 - mean(x2)/sd(x2))
model.matrix(~ x + x2)
y <- ap + bp*xs + bp2*x2s
y
(b <- (bp/sd(x) + x))
(b <- (bp/sd(x) + mean(x)))
(b2 <- (bp2/sd(x2) + mean(x2)))
(y <- ap + b*x + b2*x2)
sd(x2)
(b <- (bp*sd(x) + mean(x)))
(b2 <- (bp2*sd(x2) + mean(x2)))
(y <- ap + b*x + b2*x2)
(b <- bp*xs/x)
xs
xs
x
xs/x
(b <- bp*xs/x)
(b2 <- bp2*x2s/x2)
(y <- ap + b*x + b2*x2)
b
x
yp <- ap + bp*xs + bp2*x2s
(y <- ap + b*x + b2*x2)
y <- array(0, c(195, 6))
for(j in 1:195){
for(k in 1:6){
y[j,k] <- (rbinom(1, N[j], p[1,j,k]))
}
}
foo <- runif(50, 1, 195)
bar <- runif(50, 1, 6)
for(i in 1:50){
y[foo[i], bar[i]] <- NA
}
y.new[is.na(y)] <- NA
p <- array(runif(3000*195*6, 0, 1), c(3000, 195, 6))
N <- array(rpois(3000*195, 10), c(3000, 195))
eval <- array(NA, c(3000, 195, 6))
E <- array(NA, c(3000, 195, 6))
E.new <- array(NA, c(3000, 195, 6))
y.new <- array(NA, c(195, 6))
library("tools", lib.loc="/Library/Frameworks/R.framework/Versions/2.15/Resources/library")
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
install.packages('devtools')
library(devtools)
?devtools
build("QICpack")
build("qicpack")
pkg_env()
R CMD BUILD QICpack
R CMD build QICpack
R CMD build "QICpack"
R CMD
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/QICcode')
build QICpack
build("QICpack")
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
build("QICcode")
check('QICpack_0.9.tar.gz')
check('QICpack')
check('QICcode')
check('QICcode')
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack_0.9.tar.gz')
Sys.getenv("PATH")
Sys.which('pdflatex')
?PATH
?.libPath
?.libPaths
"/opt/local/bin/pdflatex"
??path
file.path("/opt/local/bin/pdflatex")
Sys.which('pdflatex')
Sys.setenv(PATH=paste(Sys.getenv("PATH"),"/usr/texbin",sep=":")) # this adds /usr/texbin to the R path
Sys.getenv("PATH")
Sys.which('pdflatex')
build('QICcode')
check('QICcode')
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack_0.9.tar.gz')
build('QICcode')
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack_0.9.tar.gz')
check('QICcode')
source('QICpack_0.9.tar.gz')
build('QICcode')
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack_0.9.tar.gz')
Sys.which('pdflatex')
system("pdflatex --version")
