}
else{
Results$Cum.Wt <- NULL
}
}
else{
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, QICc = FALSE)), length(cand.set), 5, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 5]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qic(gee1)
qic <-
function(model.R, QICc = TRUE) {
require(MASS, quietly = TRUE)
require(geepack, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
n <- length(model.R$y)
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QICc <- 2 * (trace.R * (n / ( n - trace.R - 1)) - quasi.R)
QIC <-   2*(trace.R - quasi.R)
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
if(QICc=="TRUE"){
output <- data.frame(list(QICc, quasi.R, trace.R, n, px))
names(output) <- c('QICc', 'Log.QLik', 'Trace', 'n', 'px')
}
else{
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
}
return(output)
}
qictab <- function(cand.set, modnames, QICc = TRUE, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(foo) foo$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
if(QICc){
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, QICc = TRUE)), length(cand.set), 4, byrow = TRUE)
Results$QICc <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$n <- qicout[ , 4]
Results$px <- qicout[ , 5]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QICc)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 8])
}
else{
Results$Cum.Wt <- NULL
}
}
else{
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, QICc = FALSE)), length(cand.set), 5, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 5]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qic(gee1)
qic(gee1, QICc = TRUE)
qic <-
function(model.R, QICc = TRUE) {
require(MASS, quietly = TRUE)
require(geepack, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
n <- length(model.R$y)
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QICc <- 2 * (trace.R * (n / ( n - trace.R - 1)) - quasi.R)
QIC <-   2*(trace.R - quasi.R)
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
if(QICc){
output <- data.frame(list(QICc, quasi.R, trace.R, n, px))
names(output) <- c('QICc', 'Log.QLik', 'Trace', 'n', 'px')
}
else{
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
}
return(output)
}
qictab <- function(cand.set, modnames, QICc = TRUE, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(foo) foo$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
if(QICc){
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, QICc = TRUE)), length(cand.set), 4, byrow = TRUE)
Results$QICc <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$n <- qicout[ , 4]
Results$px <- qicout[ , 5]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QICc)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 8])
}
else{
Results$Cum.Wt <- NULL
}
}
else{
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, QICc = FALSE)), length(cand.set), 5, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 5]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qic(gee1)
qic(gee1, QICc = FALSE)
qic <-
function(model.R, QICc = TRUE) {
require(MASS, quietly = TRUE)
require(geepack, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
n <- length(model.R$y)
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QICc <- 2 * (trace.R * (n / ( n - trace.R - 1)) - quasi.R)
QIC <-   2*(trace.R - quasi.R)
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
if(QICc){
output <- data.frame(list(QICc, quasi.R, trace.R, n, px))
names(output) <- c('QICc', 'Log.QLik', 'Trace', 'n', 'px')
} else{
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
}
return(output)
}
qic(gee1)
qic(gee1, QIC = FALSE)
qic <- function(model.R, small = TRUE) {
require(MASS, quietly = TRUE)
require(geepack, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
n <- length(model.R$y)
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QICc <- 2 * (trace.R * (n / ( n - trace.R - 1)) - quasi.R)
QIC <-   2*(trace.R - quasi.R)
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
if(small){
output <- data.frame(list(QICc, quasi.R, trace.R, n, px))
names(output) <- c('QICc', 'Log.QLik', 'Trace', 'n', 'px')
} else{
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
}
return(output)
}
qictab <- function(cand.set, modnames, small = TRUE, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(foo) foo$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
if(small){
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, small = TRUE)), length(cand.set), 4, byrow = TRUE)
Results$QICc <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$n <- qicout[ , 4]
Results$px <- qicout[ , 5]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QICc)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 8])
}
else{
Results$Cum.Wt <- NULL
}
}
else{
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, small = FALSE)), length(cand.set), 5, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 5]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qic(gee1)
qic(gee1, small = FALSE)
qictab(model.set, mod.names)
data(dietox)
dietox$Cu = as.factor(dietox$Cu)
mf = formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
gee1 = geeglm(mf, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
gee1
summary(gee1)
mf2 = formula(Weight ~ Cu * Time + I(Time^2) + I(Time^3))
gee2 = geeglm(mf2, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
summary(gee2)
anova(gee2)
anova(gee1, gee2)
mf3 = formula(Weight ~ Cu + Time + I(Time^2))
gee3 = geeglm(mf3, data = dietox, id = Pig, family = gaussian, corstr = "ar1")
gee3.I = update(gee3, corstr = "independence")
gee3.Ex = update(gee3, corstr = "exchangeable")
model.set <- list(gee1, gee2, gee3, gee3.I, gee3.Ex)
mod.names <- c("gee1", "gee2", "gee3", "gee3.I", "gee3.Ex")
qictab(model.set, mod.names)
qic <- function(model.R, small = TRUE) {
require(MASS, quietly = TRUE)
require(geepack, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
n <- length(model.R$y)
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QICc <- 2 * (trace.R * (n / ( n - trace.R - 1)) - quasi.R)
QIC <-   2*(trace.R - quasi.R)
QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
if(small){
output <- data.frame(list(QICc, quasi.R, trace.R, n, px))
names(output) <- c('QICc', 'Log.QLik', 'Trace', 'n', 'px')
} else{
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
}
return(output)
}
qictab <- function(cand.set, modnames, small = TRUE, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(foo) foo$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
if(small){
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, small = TRUE)), length(cand.set), 5, byrow = TRUE)
Results$QICc <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$n <- qicout[ , 4]
Results$px <- qicout[ , 5]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QICc)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 8])
}
else{
Results$Cum.Wt <- NULL
}
}
else{
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic, small = FALSE)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$RelQLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$RelQLik/sum(Results$RelQLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 5]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qictab(model.set, mod.names)
qictab(model.set, mod.names, small = FALSE)
## a function to generate a dataset
set.seed(12345)
gendat <- function() {
id <- gl(50, 4, 200)
visit <- rep(1:4, 50)
x1 <- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
x2 <- runif(200, 0, 1)   ## within cluster varying continuous covariate
phi <- 1 + 2 * x1         ## true scale model
## the true correlation coefficient rho for an ar(1)
## correlation structure is 0.667.
rhomat <- 0.667 ^ outer(1:4, 1:4, function(x, y) abs(x - y))
chol.u <- chol(rhomat)
noise <- as.vector(sapply(1:50, function(x) chol.u %*% rnorm(4)))
e <- sqrt(phi) * noise
y <- 1 + 3 * x1 - 2 * x2 + e
dat <- data.frame(y, id, visit, x1, x2)
dat
}
dat <- gendat()
fit1 <- geeglm(y ~ x1, id = id, data = dat, corstr = "ar1") #,sformula = ~ x1)
summary(fit)
# Add random variable with no relation to y
dat$x3 <- rnorm(200, 0, 1)
dat$x4 <- rnorm(200, 0, 1)
dat$x5 <- rnorm(200, 0, 10)
dat$x6 <- rnorm(200, 10, 1)
fit2 <- geeglm(y ~ x1 + x2, id = id, data = dat, corstr = "ar1") # should be best model
fit3 <- geeglm(y ~ x1 + x2 + x3, id = id, data = dat, corstr = "ar1")
fit4 <- geeglm(y ~ x1 + x2 + x3 + x4, id = id, data = dat, corstr = "ar1")
fit5 <- geeglm(y ~ x1 + x2 + x5, id = id, data = dat, corstr = "ar1")
fit6 <- geeglm(y ~ x1 + x2 + x6, id = id, data = dat, corstr = "ar1")
model.list <- list(fit1, fit2, fit3, fit4, fit5, fit6)
qictab(model.list, c(1,2,3,4,5,6))
