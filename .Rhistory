return(Results)
}
qictab(model.set, mod.names)
matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand), 4, byrow = TRUE)
matrix(unlist(lapply(X = cand, FUN = qic)), length(cand), 4, byrow = TRUE)
matrix(unlist(lapply(X = model.set, FUN = qic)), length(model.set), 4, byrow = TRUE)
mod.names
results <- NULL
results <- data.frame(mod.names)
results
aictab
?aictab
model.set <- list(gee1, gee2, gee3, gee3.I, gee3.Ex)
mod.names <- c("gee1", "gee2", "gee3", "gee3.I", "gee3.Ex")
qictab(model.set, mod.names)
qictab(model.set, mod.names, sort = TRUE)
cand.set <- model.set
modnames <- mod.names
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$QLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$Delta.QIC <- Results$QIC - min(Results$QIC)
Results$QICwt <- Results$Quasi.Lik/sum(Results$Quasi.Lik)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[rev(order(Results[, 2])), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
qictab(model.set, mod.names)
qictab(model.set, mod.names, sort = TRUE)
Results
C
Results$QICwt <- Results$QLik/sum(Results$QLik)
Results <- Results[rev(order(Results[, 2])), ]
Results$Cum.Wt <- cumsum(Results[, 7])
Results
Results$QICwt
print(Results$QICwt, dig = 3)
?cumsum
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$QLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$Delta.QIC <- Results$QIC - min(Results$QIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[rev(order(abs(Results[, 2])), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$QLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$Delta.QIC <- Results$QIC - min(Results$QIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[rev(order(abs(Results[, 2]))), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qictab(model.set, mod.names)
set.seed(12345)
gendat <- function() {
id <- gl(50, 4, 200)
visit <- rep(1:4, 50)
x1 <- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
x2 <- runif(200, 0, 1)   ## within cluster varying continuous covariate
phi <- 1 + 2 * x1         ## true scale model
## the true correlation coefficient rho for an ar(1)
## correlation structure is 0.667.
rhomat <- 0.667 ^ outer(1:4, 1:4, function(x, y) abs(x - y))
chol.u <- chol(rhomat)
noise <- as.vector(sapply(1:50, function(x) chol.u %*% rnorm(4)))
e <- sqrt(phi) * noise
y <- 1 + 3 * x1 - 2 * x2 + e
dat <- data.frame(y, id, visit, x1, x2)
dat
}
dat <- gendat()
fit1 <- geeglm(y ~ x1, id = id, data = dat, corstr = "ar1") #,sformula = ~ x1)
summary(fit)
# Add random variable with no relation to y
x3 <- rnorm(200, 0, 1)
x4 <- rnorm(200, 0, 1)
x5 <- rnorm(200, 0, 10)
x6 <- rnorm(200, 10, 1)
fit2 <- geeglm(y ~ x1 + x2, id = id, data = dat, corstr = "ar1")
fit3 <- geeglm(y ~ x1 + x2 + x3, id = id, data = dat, corstr = "ar1")
fit4 <- geeglm(y ~ x1 + x2 + x3 + x4, id = id, data = dat, corstr = "ar1")
fit5 <- geeglm(y ~ x1 + x2 + x5, id = id, data = dat, corstr = "ar1")
fit6 <- geeglm(y ~ x1 + x2 + x6, id = id, data = dat, corstr = "ar1")
qictab(model.list)
model.list <- list(fit1, fit2, fit3, fit4, fit5, fit6)
qictab(model.list)
qictab(model.list, c(1,2,3,4,5,6))
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$QLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$Delta.QIC <- Results$QIC - min(Results$QIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[rev(order(Results[, 6])), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qictab(model.list, c(1,2,3,4,5,6))
?rev
?order
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$QLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$Delta.QIC <- Results$QIC - min(Results$QIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
qictab(model.list, c(1,2,3,4,5,6))
glmm1 <- lmer(y ~ x1 + (1|id), data = dat)
glmm2 <- lmer(y ~ x1 + x2 + (1|id), data = dat)
dat
dat$x3 <- rnorm(200, 0, 1)
dat$x4 <- rnorm(200, 0, 1)
dat$x5 <- rnorm(200, 0, 10)
dat$x6 <- rnorm(200, 10, 1)
fit2 <- geeglm(y ~ x1 + x2, id = id, data = dat, corstr = "ar1")
fit3 <- geeglm(y ~ x1 + x2 + x3, id = id, data = dat, corstr = "ar1")
fit4 <- geeglm(y ~ x1 + x2 + x3 + x4, id = id, data = dat, corstr = "ar1")
fit5 <- geeglm(y ~ x1 + x2 + x5, id = id, data = dat, corstr = "ar1")
fit6 <- geeglm(y ~ x1 + x2 + x6, id = id, data = dat, corstr = "ar1")
model.list <- list(fit1, fit2, fit3, fit4, fit5, fit6)
qictab(model.list, c(1,2,3,4,5,6))
library(lme4)
glmm1 <- lmer(y ~ x1 + (1|id), data = dat)
glmm2 <- lmer(y ~ x1 + x2 + (1|id), data = dat)
glmm3 <- lmer(y ~ x1 + x2 + x3 + (1|id), data = dat)
glmm4 <- lmer(y ~ x1 + x2 + x3 + x4 + (1|id), data = dat)
glmm5 <- lmer(y ~ x1 + x2 + x5 + (1|id), data = dat)
glmm6 <- lmer(y ~ x1 + x2 + x6 + (1|id), data = dat)
aic.list <- list(glmm1, glmm2, glmm3, glmm4, glmm5, glmm6)
aictab(aic.list)
library(AICcmodavg)
aictab(aic.list, c(1,2,3,4,5,6))
?lmer
glmm1 <- lmer(y ~ x1 + (1|id), data = dat, REML = FALSE)
glmm2 <- lmer(y ~ x1 + x2 + (1|id), data = dat, REML = FALSE)
glmm3 <- lmer(y ~ x1 + x2 + x3 + (1|id), data = dat, REML = FALSE)
glmm4 <- lmer(y ~ x1 + x2 + x3 + x4 + (1|id), data = dat, REML = FALSE)
glmm5 <- lmer(y ~ x1 + x2 + x5 + (1|id), data = dat, REML = FALSE)
glmm6 <- lmer(y ~ x1 + x2 + x6 + (1|id), data = dat, REML = FALSE)
library(AICcmodavg)
aic.list <- list(glmm1, glmm2, glmm3, glmm4, glmm5, glmm6)
aictab(aic.list, c(1,2,3,4,5,6))
qictab(model.list, c(1,2,3,4,5,6))
plot(dat$x3, dat$y)
plot(dat$x1, dat$y)
plot(dat$x2, dat$y)
aictab
aictab.mer
AICmodavg
AICcmodavg
aictab.glm
qic <-
function(model.R) {
require(MASS, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- 2*(trace.R - quasi.R)
#QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
return(output)
}
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$QLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 7])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
data(dietox)
dietox$Cu = as.factor(dietox$Cu)
mf = formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
gee1 = geeglm(mf, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee1
summary(gee1)
mf2 = formula(Weight ~ Cu * Time + I(Time^2) + I(Time^3))
gee2 = geeglm(mf2, data = dietox, id = Pig, family = poisson, corstr = "ar1")
summary(gee2)
anova(gee2)
anova(gee1, gee2)
mf3 = formula(Weight ~ Cu + Time + I(Time^2))
gee3 = geeglm(mf3, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee3.I = update(gee3, corstr = "independence")
gee3.Ex = update(gee3, corstr = "exchangeable")
model.set <- list(gee1, gee2, gee3, gee3.I, gee3.Ex)
mod.names <- c("gee1", "gee2", "gee3", "gee3.I", "gee3.Ex")
qictab(model.set, mod.names)
options(scipen = 10)
qictab(model.set, mod.names)
qictab(model.set, mod.names)
options(scipen = 5)
qictab(model.set, mod.names)
print(qictab(model.set, mod.names), dig = 3)
options(scipen = 10)
print(qictab(model.set, mod.names), dig = 3)
?print
?round
round(qictab(model.set, mod.names), digits = 3)
print(qictab(model.set, mod.names), digits = 3)
set.seed(12345)
gendat <- function() {
id <- gl(50, 4, 200)
visit <- rep(1:4, 50)
x1 <- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
x2 <- runif(200, 0, 1)   ## within cluster varying continuous covariate
phi <- 1 + 2 * x1         ## true scale model
## the true correlation coefficient rho for an ar(1)
## correlation structure is 0.667.
rhomat <- 0.667 ^ outer(1:4, 1:4, function(x, y) abs(x - y))
chol.u <- chol(rhomat)
noise <- as.vector(sapply(1:50, function(x) chol.u %*% rnorm(4)))
e <- sqrt(phi) * noise
y <- 1 + 3 * x1 - 2 * x2 + e
dat <- data.frame(y, id, visit, x1, x2)
dat
}
dat <- gendat()
fit1 <- geeglm(y ~ x1, id = id, data = dat, corstr = "ar1") #,sformula = ~ x1)
summary(fit)
# Add random variable with no relation to y
dat$x3 <- rnorm(200, 0, 1)
dat$x4 <- rnorm(200, 0, 1)
dat$x5 <- rnorm(200, 0, 10)
dat$x6 <- rnorm(200, 10, 1)
fit2 <- geeglm(y ~ x1 + x2, id = id, data = dat, corstr = "ar1")
fit3 <- geeglm(y ~ x1 + x2 + x3, id = id, data = dat, corstr = "ar1")
fit4 <- geeglm(y ~ x1 + x2 + x3 + x4, id = id, data = dat, corstr = "ar1")
fit5 <- geeglm(y ~ x1 + x2 + x5, id = id, data = dat, corstr = "ar1")
fit6 <- geeglm(y ~ x1 + x2 + x6, id = id, data = dat, corstr = "ar1")
model.list <- list(fit1, fit2, fit3, fit4, fit5, fit6)
qictab(model.list, c(1,2,3,4,5,6))
qic <-
function(model.R) {
require(MASS, quietly = TRUE)
check.class <- class(model.R)
known <- NULL
if(identical(check.class[1], "geeglm")) {
known[1] <- 1
}
if(identical(check.class[1], "geese")) {
stop("\nQIC function not defined for object of class geese rerun models using geeglm in geepack\n")
known[2] <- 1
}
if(sum(known) < 1) {
stop("\nFunction not defined for this object class\n")
}
model.indep <- update(model.R, corstr = "independence")
# Quasilikelihood
mu.R <- model.R$fitted.values
y <- model.R$y
type <- family(model.R)$family
quasi.R <- switch(type,
poisson = sum((y*log(mu.R)) - mu.R),
gaussian = sum(((y - mu.R)^2)/-2),
binomial = sum(y*log(mu.R/(1 - mu.R)) + log(1 - mu.R)),
Gamma = sum(-y/(mu.R - log(mu.R))),
stop("Error: distribution not defined for this function"))
# Trace Term (penalty for model complexity)
omegaI <- ginv(model.indep$geese$vbeta.naiv) # Omega-hat(I) via Moore-Penrose
Vr <- model.R$geese$vbeta
trace.R <- sum(diag(omegaI %*% Vr))
px <- length(mu.R) # number non-redunant columns in design matrix
# QIC
QIC <- 2*(trace.R - quasi.R)
#QICu <- (-2)*quasi.R + 2*px    # Approximation assuming model structured correctly
output <- data.frame(list(QIC, quasi.R, trace.R, px))
names(output) <- c('QIC', 'Log.QLik', 'Trace', 'px')
return(output)
}
qictab <- function(cand.set, modnames, sort = TRUE) {
check.y <- lapply(X = cand.set, FUN = function(b) b$y)
if(length(unique(check.y)) > 1)
stop("\nThe same response variable must be used for all models\n")
Results <- NULL
Results <- data.frame(Model = modnames)
qicout <- matrix(unlist(lapply(X = cand.set, FUN = qic)), length(cand.set), 4, byrow = TRUE)
Results$QIC <- qicout[ , 1]
Results$LQLik <- qicout[ , 2]
Results$Trace <- qicout[ , 3]
Results$px <- qicout[ , 4]
Results$dQIC <- Results$QIC - min(Results$QIC)
Results$QLik <- exp(-0.5 * Results$dQIC)
Results$QICwt <- Results$QLik/sum(Results$QLik)
if(length(unique(Results$QIC)) != length(cand.set))
warning("\nCheck model structure carefully as some models may be redundant\n")
if(sort){
Results <- Results[order(Results[, 6]), ]
Results$Cum.Wt <- cumsum(Results[, 8])
}
else{
Results$Cum.Wt <- NULL
}
class(Results) <- c("qictab", "data.frame")
return(Results)
}
dat <- gendat()
fit1 <- geeglm(y ~ x1, id = id, data = dat, corstr = "ar1") #,sformula = ~ x1)
summary(fit)
# Add random variable with no relation to y
dat$x3 <- rnorm(200, 0, 1)
dat$x4 <- rnorm(200, 0, 1)
dat$x5 <- rnorm(200, 0, 10)
dat$x6 <- rnorm(200, 10, 1)
fit2 <- geeglm(y ~ x1 + x2, id = id, data = dat, corstr = "ar1")
fit3 <- geeglm(y ~ x1 + x2 + x3, id = id, data = dat, corstr = "ar1")
fit4 <- geeglm(y ~ x1 + x2 + x3 + x4, id = id, data = dat, corstr = "ar1")
fit5 <- geeglm(y ~ x1 + x2 + x5, id = id, data = dat, corstr = "ar1")
fit6 <- geeglm(y ~ x1 + x2 + x6, id = id, data = dat, corstr = "ar1")
model.list <- list(fit1, fit2, fit3, fit4, fit5, fit6)
qictab(model.list, c(1,2,3,4,5,6))
exp(-0.5*-214)
aictab.glm
wd
get.wd
getwd
wd('/Users/Dan/Documents/Rpackages/QICpack/')
setwd('/Users/Dan/Documents/Rpackages/QICpack/')
source(qic.R)
source('qic.R')
source('qictab.R')
library(geepack)
data(detox)
data('detox')
data(dietox)
package.skeleton('QICpack')
?geepack
library(geepack)
?geepack
?unmarked
library(unmarked)
?unmarked
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack')
source('QICpack_0.9.tar.gz')
warnings()
install.packages("~/Documents/Rpackages/git/qicpack/QICpack_0.9.tar.gz", repos = NULL, type = "source")
library("QICpack", lib.loc="/Library/Frameworks/R.framework/Versions/2.15/Resources/library")
data(dietox)
dietox$Cu = as.factor(dietox$Cu)
mf = formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
gee1 = geeglm(mf, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee1
summary(gee1)
mf2 = formula(Weight ~ Cu * Time + I(Time^2) + I(Time^3))
gee2 = geeglm(mf2, data = dietox, id = Pig, family = poisson, corstr = "ar1")
summary(gee2)
anova(gee2)
anova(gee1, gee2)
mf3 = formula(Weight ~ Cu + Time + I(Time^2))
gee3 = geeglm(mf3, data = dietox, id = Pig, family = poisson, corstr = "ar1")
gee3.I = update(gee3, corstr = "independence")
gee3.Ex = update(gee3, corstr = "exchangeable")
model.set <- list(gee1, gee2, gee3, gee3.I, gee3.Ex)
mod.names <- c("gee1", "gee2", "gee3", "gee3.I", "gee3.Ex")
print(qictab(model.set, mod.names), digits = 3)
?QICpack
?qic
citation()
?AICcmodavg
citation('AICcmodavg')
citation(QICpack)
library(QICpack)
library("QICpack")
citation("QICpack")
source("QICpack")
source("QICpack_0.9.tar.gz")
citation("QICpack")
library(QICpack)
citation("QICpack")
source("QICpack_0.9.tar.gz")
warnings()
source("QICpack_0.9.tar.gz")
detach("package:QICpack", unload=TRUE)
remove.packages("QICtest")
remove.packages("QICpack")
source("QICpack_0.9.tar.gz")
setwd('/Users/Dan/Documents/Rpackages/git/qicpack/')
source('QICpack_0.9.tar.gz')
warnings()
source('QICpack_0.9.tar.gz')
